#include "pch.h"
#include "paint_sa.h"
#include "utils/util.h"
#include "../../include/kiero/minhook/MinHook.h"

PaintMgr& Paint = PaintMgr::Get();

// This works with silentpatch
static auto oEntityRender = (void(__fastcall*)(CVehicle*))0x534310;
void __fastcall hkEntityRender(CVehicle* pVeh) {
    if (!pVeh || pVeh->m_nType != ENTITY_TYPE_VEHICLE) {
        oEntityRender(pVeh);
        return;
    }
    auto& data = Paint.GetData(pVeh);

    /*
        Applying our custom material colors here
    */
    for (auto& it : data.m_nMapInfoList) {
        if (it.second.m_bRecolor) {
            it.second.m_nOriginalColor = it.first->color;
            it.first->color = it.second.m_nColor;
            it.second.m_nOriginalGeometryFlags = it.second.m_pGeometry->flags;
            it.second.m_pGeometry->flags |= rpGEOMETRYMODULATEMATERIALCOLOR;
        }
    }
    oEntityRender(pVeh);
};

PaintMgr::PaintMgr() {
    MH_Initialize();
    MH_CreateHook((void*)0x534310, hkEntityRender, (void**)&oEntityRender);
    MH_EnableHook((void*)0x534310);

    // This doesn't work for helicopters? SilentPatch?
    static ThiscallEvent<AddressList<0x55332A, H_CALL>, PRIORITY_BEFORE, ArgPickN<CVehicle*, 0>, void(CVehicle*)> vehicleResetAfterRender;
    vehicleResetAfterRender += [this](CVehicle* pVeh) {
        PaintData& data = m_VehPaint.Get(pVeh);
        for (auto& it : data.m_nMapInfoList) {
            if (it.second.m_bRecolor) {
                it.first->color = it.second.m_nOriginalColor;
                it.second.m_pGeometry->flags = it.second.m_nOriginalGeometryFlags;
            }
        }
    };
}

void PaintMgr::PaintData::SetMatColor(RpMaterial* material, RpGeometry* geometry, RwRGBA color) {
    auto& matInfo = m_nMapInfoList[material];
    if ((material->color.red == 0x3C && material->color.green == 0xFF && material->color.blue == 0x00)
            || (material->color.red == 0xFF && material->color.green == 0x00 && material->color.blue == 0xAF)) {
        matInfo.m_bRecolor = true;
        matInfo.m_nColor = color;
        matInfo.m_pGeometry = geometry;
    }
}

PaintMgr::PaintData& PaintMgr::GetData(CVehicle *pVeh) {
    return m_VehPaint.Get(pVeh);
}

static void NodeWrapperRecursive(RwFrame* frame, CVehicle* pVeh, std::function<void(RwFrame*)> func) {
    if (frame) {
        func(frame);
        if (RwFrame* newFrame = frame->child) {
            NodeWrapperRecursive(newFrame, pVeh, func);
        }
        if (RwFrame* newFrame = frame->next) {
            NodeWrapperRecursive(newFrame, pVeh, func);
        }
    }
    return;
}

void PaintMgr::SetColor(CEntity* pEntity, CRGBA color) {
    RwFrame* pFrame = (RwFrame*)pEntity->m_pRwClump->object.parent;
    NodeWrapperRecursive(pFrame, pVeh, [&](RwFrame* frame) {
        RwFrameForAllObjects(frame, [](RwObject* object, void* data) -> RwObject* {
            if (object->type == rpATOMIC) {
                RpAtomic* atomic = reinterpret_cast<RpAtomic*>(object);

                CEntity* pEntity = reinterpret_cast<pEntity*>(data);
                PaintData* pData = reinterpret_cast<PaintData*>(pEntity);

                for (int i = 0; i < atomic->geometry->matList.numMaterials; ++i) {
                    pData->SetMatColor(atomic->geometry->matList.materials[i], atomic->geometry,
                    {255, 0, 0, 255});
                }
            }
            return object;
        }, pEntity);
    });
}